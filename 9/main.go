package main

import (
	"fmt"
	"time"
)

// Функция принимает числа из одного канала, удваивает их и передаёт в другой
func conveyor(inputChan chan int, outputChan chan int) {
	// Пока канал не будет закрыт будем извлекать из него значения
	// Используя range можно не прописывать условие на текущее состояние канала
	for value := range inputChan {
		time.Sleep(100 * time.Millisecond) // Ожидание 1 секунду
		outputChan <- 2 * value
	}
	// Закрваем канал в который попадвают удвоенные числа
	close(outputChan)
}

func main() {
	// Создаём небуферизированный канал для передачи чисел
	numbersChan := make(chan int)
	// Создаём небуферизированный канал для передачи удвоенных чисел
	doublesChan := make(chan int)
	// Инициализация числового массива
	numbers := [...]int{2, 4, 6, 8, 10, 12}
	// Запускаем горутину, в которой мы отправляем все числа массива в канал
	go func() {
		for _, i := range numbers {
			// Записываем очередное число в канал. Так как канал небуферизированный,
			// то слудующее значение в канал не запишется, пока другая горутина (в
			// которой выполняется функция conveyor) не возьмет из него значение
			numbersChan <- i
		}
		// Закрываем канал
		close(numbersChan)
	}()

	// Запускаем конвейер
	go conveyor(numbersChan, doublesChan)

	// Канал doublesChan тоже небуферизированный, поэтому нужно сразу доставать из
	// него значения. Можно делать это в main(так как он является отдельной горутиной)
	// Пока doublesChan не будет закрыт мы будем ждать из него значения, поэтому можно
	// не использовать вейт группу
	for z := range doublesChan {
		fmt.Println(z)
	}
}
